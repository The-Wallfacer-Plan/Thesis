\chapter{Related Work} \label{ch:related}

 \section{For \dFOT}\label{sec:dgf_related}
 
 \todo{unify the format}

Our study is related to the following lines of research:

\subsection{Directed Grey-box Fuzzing}
Some other DGF techniques have been proposed besides \dFOT.
\aflgo~\cite{Bohme:2017:DGF} is the state-of-the-art directed grey-box fuzzer which utilizes a simulated annealing-based power schedule that gradually assigns more energy to inputs that hold the trace closer to the target sites.
In \aflgo, the authors proposed a novel idea of calculating the distance between the input traces and the target sites.
This is a good starting point by combining such target distance calculation with grey-box fuzzer.
\dFOT is inspired from \aflgo however provides significant improvements on both the static analysis and dynamic fuzzing.
As shown in \S\ref{sec:eval}, \dFOT generally outperforms \aflgo in terms of reaching the targets and reproducing crashes, thanks to embedding in-depth consideration about the four desired properties into the design.
SeededFuzz~\cite{tase16:seededfuzz} uses various program analysis techniques to facilitate the generation and selection of initial seeds which helps to achieve the goal of directed fuzzing.
Equipped with the improved seed selection and generation techniques, SeededFuzz can reach more critical sites and find more vulnerabilities.
The core techniques of SeededFuzz are orthogonal to \dFOT because SeededFuzz focuses on the quality of initial seed inputs while \dFOT focuses on the four desirable properties regardless of initial seeds.

Note that our proposed four properties can also be applied for DGF on programs where the source code is unavailable. In fact, we are extending {\dFOT} to be able to work on the binary-only fuzzing scenarios. Technically, the target sites can be determined by binary-code matching techniques on attack surface identification~\cite{bingo,tse18}; the static analysis can be achieved with binary analysis tools such as IDA~\cite{ida}; and the instrumentation can be done by dynamic binary instrumentators such as Intel Pin~\cite{pin}. We envision the extended {\dFOT} can piggyback on these techniques and demonstrate its effectiveness even further.

\subsection{Directed Symbolic Execution}.
Directed Symbolic Execution (DSE) is one of the most related techniques to DGF as it also aims to execute target sites of the PUT.
Several works have been proposed for DSE~\cite{Godefroid:2005:DART, Ma:2011:DSE:2041552.2041563, Haller:2013:DOG, Jin:2012, Marinescu:2013:katch}.
These DSE techniques rely on heavyweight program analysis and  constraint-solving to reach the target sites systematically.
A typical example of DSE is Katch~\cite{Marinescu:2013:katch}, which relies on symbolic execution, augmented by several synergistic heuristics based on static and dynamic program analysis.
Katch can effectively find bugs in incomplete patches and increase the patch coverage comparing to manual test suite.
However, as discussed in ~\cite{Bohme:2017:DGF}, DGF is generally more effective on real-world programs as DSE techniques suffer from the infamous path-explosion problem~\cite{Stephens2016Driller}.
In contrast to DSE, \dFOT relies on  lightweight program analysis, which ensures its scalability and execution efficiency.

\noindent\textbf{Taint Analysis Aided Fuzzing}.
Taint analysis is also widely used to facilitate directed white-box testing~\cite{Ganesh:2009:TDW, rawat:2017, wangwgz:2010, Angora,2017arXiv170907101L}.
The key intuition of using taint analysis in fuzzing is to identify \emph{certain parts} of the input which should be mutated with priority.
In such a way, the fuzzer can drastically reduce the search space for reaching certain desired locations.
Taint based approaches are more scalable than the DSE techniques and can help the fuzzer to reach certain preferable locations such as rare branches in Fairfuzz~\cite{2017arXiv170907101L} or checksum related code in TaintScope~\cite{wangwgz:2010}.
Different from \dFOT, these techniques are not fed with \emph{given target sites} (e.g., file name and line numbers in our scenario) but based on source-sink pairs.
Thus, such techniques do not have advantages in scenarios where the targets are clear, such as patch testing and crash reproduction. 


\subsection{Coverage-based Grey-box Fuzzing}.
The purposes of coverage-based grey-box fuzzing (CGF) and DGF are different. However, some techniques proposed to boost the performance of CGF could also be adopted by \dFOT.
For example, CollAFL~\cite{CollAFL} utilizes a novel hash algorithm to solve AFL's instrumentation collision problem.
Skyfire~\cite{junjie:2017sp:skyfire} learns a probabilistic context sensitive grammar (PGSG) to specify both syntax features and semantic rules, and then the second step leverages the learned PCSG to generate new test seeds.
Xu \textit{et al.}~\cite{XuKMK:2017} proposed a set of new operating primitives to improve the performance of grey-box fuzzers.
Another important topic in CGF is about guiding the fuzzer through path constraints. \cite{Stephens2016Driller, rawat:2017, LiCMLLT17, Angora, tfuzz} aim to help the CGFs to break through path constraints.
Moreover, Orthrus~\cite{Shastry:LNCS2017:Orthrus} applies static analysis on AST, CFG, and CG to extract complicated tokens via customizable queries. 
\dFOT can benefit through combining with the aforementioned techniques.

\section{For \mtfuzz}\label{sec:mtfuzz_related}

\subsection{Static Concurrency Bug Prediction}
Static concurrency bug predictors aim to approximate the runtime behaviours of a concurrent program without actual execution. Several static approaches have been proposed for analyzing pthread and Java  programs~\cite{pratikakis2006locksmith,Vojdani2009,DBLP:conf/cgo/SuiDX16,Liupldi2018,racerdoopsla2018}. LOCKSMITH~\cite{pratikakis2006locksmith} uses existential types to correlate locks and data in dynamic heap structures for race detection. Goblint~\cite{Vojdani2009} relies on a thread-modular constant propagation and points-to analysis for detecting concurrent bugs by considering conditional locking schemes. FSAM~\cite{DBLP:conf/cgo/SuiDX16} proposes a sparse flow-sensitive pointer analysis for pthread C programs  using context-sensitive thread interleaving analysis. 
D4~\cite{Liupldi2018} presents a real-time concurrency bug detection approach using parallel and incremental pointer analysis. 
Currently \mtfuzz relies on lightweight static results to guide GBFs to perform three categories of instrumentation for efficient fuzzing. We envision that \mtfuzz can benefit more by integrating insights from these aforementioned static bug prediction techniques.

\subsection{Dynamic Analysis on Concurrency Bugs}
There also exists a large body of dynamic analyzers.
Essentially these can be divided into two categories: the concurrency bug detection techniques and the strategies to trigger violation conditions that can be captured by these detection techniques.


Dynamic detectors~\cite{pldi09_fasttrack,lockset_SavageABNS97,kcc:tsan,JinTLL10,YuNPP12} typically instrument target programs and monitor the memory and synchronization events~\cite{mtbugs_survey}. The two fundamentals are \emph{happens-before model}~\cite{pldi09_fasttrack} and \emph{lockset models}~\cite{lockset_SavageABNS97}; the former reports a race condition when two threads access a shared memory location and the accesses are
causally unordered, and the latter considers a potential race if two threads access a shared memory location without locking. Modern detectors such as \ts~\cite{kcc:tsan}, Valgrind~\cite{helgrind} usually apply a hybrid strategy to combine these two models for accuracy and efficiency. Our work does not aim to improve the existing dynamic detection techniques. In fact, we rely on \ts to detect concurrency bugs.


The other dynamic analyses focus on how to trigger the concurrency violation conditions. These include the random testings that mimic non-deterministic program executions~\cite{Sen07,Sen08,JoshiPSN09,ParkS08,CaiC12}, the regression testing methods~\cite{TerragniCZ15,YuHW18} that targets interleavings from code changes, the model checking~\cite{FlanaganG05,ZaksJ08,YangCGK07,yang2008inspect} and hybrid constraint solving~\cite{pldi14_maxmodel,Huang15,icse18_ufo} approaches that systematically checks or execute possible thread schedules, or heuristically avoid fruitless executions~\cite{GuoKWYG15,GuoKW16}. Our work differs from all these works in that our goal is to cover more execution paths in the programs by generating more valuable seeds. This has two benefits. On one hand, usually the provided seeds are not able to cover enough paths even when the PUTs are executed with single thread, and \mtfuzz fills the gap. On the other hand, seeds that execute different parts of the code segments tend to require different execution time, memory, and other resources, which influences the actual interleavings intrinsically. Indeed, we also provide the schedule-intervention instrumention. However the main goal is to diversify the schedule introduced interleavings (i.e., transitions).

\subsection{Dynamic Fuzzing Techniques}
There have been quite a few of fuzzing techniques to improve the effectiveness of exposing vulnerabilities.

For general-purpose fuzzing~\cite{Bohme:2016:CGF,LiCMLLT17,CollAFL,Angora,FairFuzz,redqueen}, the most common strategies are to utilize more feedbacks for execution path explorations. Steelix~\cite{LiCMLLT17} applies a lightweight binary transformation to keep track of program states during magic byte comparisons, which helps guide where and how the mutations will be processed. Angora~\cite{Angora} distinguishes different calling context when calculating deputy instruction transitions and is able to keep more valuable seeds. \mtfuzz inspires from these two techniques in that it aims to provide more valuable feedback for multithreading environment: the stratified coverage-oriented instrumentation on suspicious interleaving scope \mtiscope bookkeeps more transitions for multithreading part, and the thread-context instrumentation additionally differentiates execution context of various threads.

Other fuzzing techniques focus on detecting certain categories of bugs or vulnerabilities~\cite{Bohme:2017:DGF,hawkeye,perffuzz,slowfuzz,junjie:2017sp:skyfire,superion,smart_gbf}.  \mtfuzz focuses on the concurrently executed segments and aims to reveal more vulnerabilities and bugs in a multithreaded environment. Therefore, our strategies for seed selection, seed scheduling are all tuned for this purpose.

There are some fuzzing work for multithreading induced vulnerabilities. RAZZER~\cite{razzer} uses the deterministic thread interleaving technique implemented at the hypervisor and generates tests that can trigger data races in Linux kernel. This is a kernel fuzzer whose generated tests correspond to sequences of syscalls; while \mtfuzz mutates the input file content of an application program. Liu et al~\cite{LiuZLZ018} is the most relevant to \mtfuzz in that it is also a file fuzzer that works for multithreaded user-space programs. One major difference is their work only detects concurrency bug induced vulnerabilities. In terms of methodologies, their work relies on heavyweight static analysis from LOCKSMITH~\cite{pratikakis2006locksmith} therefore it faces scalability issues. On the other hand, we propose our novel exploration-oriented instrumentation and the comprehensive strategies to generate more seeds relevant with multithreading. The approach is both scalable and effective.

\section{For the Security Type System}

There is a large body of work on language-based information flow security. We shall discuss only closely related work.

We have discussed extensively the work by Banerjee and Naumann~\cite{Banerjee:2005ht} and highlights the major differences between our work and theirs in Section~\ref{sec:sta_intro}.


Flow-sensitive and value-dependent information flow type systems
provide a general treatment of security types that may depend on other
program variables or execution
contexts~\cite{Toby2016csf,Polikarpova16,Dependent_SIFUM_Type_Systems-AFP,Dependent_SIFUM_Refinement-AFP,Murray:2015jm,Li:2016jb,Zhang:2015bc,Li:2015vw,Lourenco:2015:DIF,Lourenco13,Swamy13,Yang12POPL,MantelSS11,Nanevski11,SwamyCC10,Zheng:2007cd,Tse07,Li:csf17,Hunt:2006:FST:1111037.1111045}.
Hunt and Sands~\cite{Hunt:2006:FST:1111037.1111045} proposed a
flow-sensitive type system where order of execution is taken into
account in the analysis, and demonstrated that the system is precise
but can be simply described.
Mantel et. al.~\cite{MantelSS11} introduced a rely-guarantee style
reasoning for information flow security in which the same variable can
be assigned different security levels depending on whether some
assumption is guaranteed, which is similar to our notion of
permission-dependent security types.
Li and Zhang~\cite{Li:csf17} proposed 
both flow-sensitive and path-sensitive information flow analysis with
program transformation techniques and dependent types.
Information flow type systems that may depend on execution contexts
have been considered in work on program synthesis~\cite{Polikarpova16} and
dynamic information flow control~\cite{Yang12POPL}. Our permission context can be seen as a
special instance of execution context, however, our intended
applications and settings are different from \cite{Yang12POPL,Polikarpova16},
and issues such as parameter laundering does not occur in their
setting. 
Louren\c{c}o and Caires~\cite{Lourenco:2015:DIF} provided a precise dependent type
system where security labels can be indexed by data structures, which
can be used to encode the dependency of security labels on other
values in the system.
It may be possible to encode our notion of security types as a
dependent type in their setting, by treating permission sets
explicitly as an additional parameter to a function or a service, and
to specify security levels of the output of the function as a type
dependent on that parameter.  Currently it is not yet clear to us how
one could give a general construction of the index types in their type
system that would correspond to our security types, and how the merge
operator would translate to their dependent type constructors, among
other things.
We leave the exact correspondence to the future work.


Recent research on information flow has also been conducted to deal
with Android security issues
(\cite{Ernst:2014,Chin:2011wa,Nadkarni:2016tf,Lortz:2014ku,Gunadi:2015,Chaudhuri:2009ii,Fuchs2010}).
SCandroid~\cite{Chaudhuri:2009ii,Fuchs2010} is a tool automating
security certification of Android apps that focuses on typing
communication between applications. Unlike our work, they do not
consider implicit flows, and do not take into account access control
in their type system. Ernst et al~\cite{Ernst:2014} proposed a
verification model, SPARTA, for use in app stores to guarantee that
apps are free of malicious information flows. Their approach requires
the collaboration between software vendor and app store auditor and
the additional modification of Android permission model to fit for
their Information Flow Type-checker;
soundness proof is also absent. Our work is done in the context of
providing information flow security \emph{certificates} for Android
applications, following the Proof-Carrying-Code  architecture by
Necula and Lee~\cite{necula:pcc:1996} and does not require extra
changes on existing Android application supply chain systems.
