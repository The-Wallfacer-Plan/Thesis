% !TeX root =../../main.tex

\chapter{Discussions} \label{ch:discuss}
In this chapter, we will briefly discuss the differences of the two applied system securing approaches in terms of the capability and the practicality.

It is observable that grey-box fuzzing is quite effective in revealing vulnerabilities caused by application crashes in a wide range of C or C++ programs. In fact, most of the binary CVEs assigned in the latest four years are found by fuzzers. In particular, \FOT and its extensions \dFOT and \mtfuzz have been able to discover more than 200 security bugs (c.f., Appendix~\ref{app:bugs}), among these 51 CVE IDs have been assigned. Despite that, it is worth noting that fuzzing itself almost only detects implementation relevant vulnerabilities caused by crashes which is rather specific to the applied program languages. Indeed, with some argumentation, fuzzing is able to detect certain logic errors by applying some differential fuzzing techniques~\cite{nezha}. However, the determination of the vulnerabilities still relies on the observations of crash behaviors that may or may not be artificially instrumented. In fact, fuzzing only copes with the very concrete issues occur in certain software. Moreover, Fuzzing cannot guarantee that the underlying programs are free of bugs as it essentially knows nothing about the actual coverage.

Conversely, verification usually relies on top-down modeling of the vulnerability behaviors and rigor proofs. The merits are that verification usually guarantees that certain security property holds under all circumstances, and are not restricted specific software. However, the problem of verification is that the precondition required for proving is usually hard to stand, greatly reducing the practicality of the approach. With the increasing complexity of the software, it is usually impractical to apply the verification by considering all the aspects. Fortunately, it is usually possible to abstract the interested security properties with some manual efforts as assistance.

There is no silver bullet: neither of testing or verification is perfect in securing the software systems. It is however possible to combine them by utilizing the strong points and offset their weakness. And we are seeking directions to integrate them for wider ranges of scenarios in securing software systems