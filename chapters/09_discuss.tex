% !TeX root =../../main.tex

\chapter{Discussions} \label{ch:discuss}
In this chapter, we will discuss the differences of the two applied vulnerability detection approaches in terms of the capability, the practicality, as well as the potential combinations in detecting vulnerabilities for modern softwares.

It is observable that grey-box fuzzing is quite effective in revealing vulnerabilities caused by application crashes in a wide range of C or C++ programs. In fact, most of the binary CVEs assigned in the latest four years are found by fuzzers. In particular, \FOT and its extensions \dFOT and \mtfuzz have been able to discover nearly 200 security bugs (c.f., Appendix ~\ref{app:bugs}), among these 40+ CVE IDs have been assigned. Despite that, it is worth noting that fuzzing itself almost only detect implementation relevant vulnerabilities caused by crashes which is rather specific to the applied program languages. Indeed, with some argumentation, fuzzing is able to detect certain logic errors by applying some differential fuzzing techniques~\cite{nezha}. However, the determination of the vulnerabilities still relies on the observations of crash behaviors that may or may not be artificially instrumented. In fact, fuzzing only copes with the very concrete issues occur in certain software. Fuzzing cannot guarantee that the underlying programs are free of bugs as it essentially knows nothing about the actual coverage.

Conversely, verification usually relies on top-down modeling of the vulnerability behaviors and rigor proofs. The merits are that verification usually guarantees that certain security property holds under all circumstances, and are not restricted specific software. However, the problem of verification is that the precondition required for proving is usually hard to stand, greatly reducing the practicality of the approach. With the increasing complexity of the software, it is usually impractical to apply the verification by considering all the aspects. Fortunately, it is usually possible to abstract the interested security properties with some manual efforts as assistance.

As a result, neither of testing or verification is perfect in securing the software systems. It is however possible to combine them by utilizing the strong points and offset their weakness.