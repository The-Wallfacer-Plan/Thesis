% cybersecurity is important
% enumeration of cybersecurity issues among different softwares, and typical solutions
% mobile securities -- access control, mention our approach: security type system based verification, we have a prototype for our type system, and a taint-based checking implementation
% native binary security -- level is much lower, mention our approach: fuzz testing
% summarization

Software security has been growing in importance due to the increasing reliance on computer systems, the internet, and the popularity of smartphones as well as other devices that constitute the Internet of things. Due to the complexity, software security is also one of the major challenges of contemporary world. Modern software usually has multiple vulnerabilities that indicate wide ranges of security weakness in design, implementation, operation, or internet control. There are various categories of vulnerabilities, including denial-of-service attacks which result from unexpected software crashes, information leakage caused by memory access violations or design defects, privilege escalation caused by misconfigured access control mechanism. In general, there are two categories of approaches to securing a system by reducing its surface of vulnerability, namely \emph{testing} and \emph{verification}. The former models the system in an abstracted description and proves its preservations of certain properties, this is usually applies on the detection of higher level vulnerability detection such as access control. The latter is more widely used in software development procedures to reveal multi-level vulnerabilities, which generates test cases to guarantee that the underlying software works properly under certain scenarios. In this thesis, we will describe our efforts in \emph{type checking based verification} and \emph{grey-box fuzz testing} in securing various software.

Firstly, we apply the \emph{type checking based verification} on detection of information leakage vulnerability caused by inter-app communications between Android apps. Based on the permission mechanism in Android, we introduce a novel type system for enforcing secure information flow that forbids unauthorized access of sensitive data. We propose a lightweight type system featuring Android permission model, where the permissions are statically assigned to applications and are used to enforce access control in the applications. A novel feature of our type system is a typing rule for conditional branching induced by permission testing, which introduces a merging operator on security types. Owning to this, we allow more precise security policies to be enforced, which for the first time permits a practical verification on the Android platform. The soundness of our type system is proved with respect to non-interference.
% In addition, a type inference algorithm is presented for the underlying security type system, by reducing the inference problem to a constraint solving problem in the lattice of security types. 
With this type system, we are able to soundly prove the absence of potential information leakage among various apps in an Android system.

Secondly, we apply \emph{grey-box fuzz testing} (or fuzzing) to detect vulnerabilities in C and C++ programs introduced by erroneous implementation. Different from existing grey-box fuzzing techniques, we aim to improve the efficiency of dynamic fuzzing for different particular purposes with the help of static program analysis. To fulfill our goal, we build our own grey-box fuzzing framework, Fuzzing Orchestration Toolkit (FOT). Compared to others, FOT is versatile in that it can be easily configured and extended for different fuzzing purposes. Till now, FOT has integrated multiple recently developed fuzzing techniques in academia. Further, based on this framework, we have also developed two new techniques to significantly improve the effectiveness of fuzzing on particular targets and multithreaded programs.

One scenario is the directed grey-box fuzzing (DGF) which aims to resolve the lacking of directedness issue in modern grey-box fuzzers, i.e. the capability of executing towards user-specified target sites in the program.
To emphasize existing challenges in \mbox{directed} fuzzing, we propose \dFOT to feature four desired properties of directed grey-box fuzzers.
Owing to a lightweight yet precise static analysis on the program under test and the target sites, \dFOT precisely collects the information such as the call graph, function and \mbox{basic} block level distances to the targets.
During fuzzing, \dFOT~{evaluates} exercised seeds based on both static information and the \mbox{execution} traces to generate the dynamic metrics, which are then used for seed prioritization, power scheduling and adaptive \mbox{mutating}.
These strategies help \dFOT to achieve better directedness and gravitate towards the target sites.
We implemented \dFOT on top of FOT and evaluated it on various real-world \mbox{programs} under different scenarios.
The experimental results showed that \dFOT can reach the target sites and reproduce the crashes much faster than state-of-the-art grey-box fuzzers such as AFL and AFLGo. Specially, \dFOT can reduce the time to exposure for certain vulnerabilities from about 3.5 hours to 0.5 hour. 

The other scenario is to boost the fuzzing on multithreaded programs. Due to non-deterministic nature of multithreading, grey-box fuzzers usually work poorly because they are inherently incapable of tracking interleaved thread executions. We present \mtfuzz, a new grey-box fuzzing technique for multithreaded programs built on top of FOT. The core of \mtfuzz is a novel thread-aware seed generation technique which effectively produces valuable seeds to test the multithreading context. \mtfuzz relies on a set of thread-aware instrumentation methods consisting of a stratified exploration-oriented instrumentation and two complementary instrumentation. We evaluated \mtfuzz upon twelve widely used real-world applications. Our experiments showed that \mtfuzz significantly outperforms the state-of-the-art fuzzer AFL in generating multithreading relevant seeds, detecting vulnerabilities, and exposing concurrency bugs.

In practice, FOT and its extensions have been successfully in revealing various security bugs in the programs. To this end, we have detected 200+ zero-day vulnerabilities in more than 40 world famous projects, from which 45 CVEs have been assigned.

Finally, based on the attempts that we have made so far, we will discuss the differences of the two applied vulnerability detection approaches in terms of the capability, the practicality, as well as their potential combinations in detecting vulnerabilities for modern software.



% In particular, \mtfuzz detected 9 multithreading relevant zero-day vulnerabilities, 2 of which have been assigned with CVE IDs; while AFL only detected 4 vulnerabilities. By replaying against the generated seeds with the help of ThreadSanitizer, \mtfuzz detected 19 new concurrency bugs while AFL only reported 9 new concurrency bugs.

%By now, \dFOT has detected more than 41 previously unknown crashes in projects such as Oniguruma, MJS with the target sites provided by \mbox{vulnerability} prediction tools; all these crashes are confirmed and 15 of them have been assigned CVE IDs.

% With {\FOT}~and its extensions, we have found 111 new bugs from 11 projects.~Among these bugs, 18 CVEs have been assigned.

