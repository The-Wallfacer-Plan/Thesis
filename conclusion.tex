
\chapter{Discussion and Conclusion} \label{ch:conclusion}

%In this chapter, we will briefly discuss the differences of the two applied system securing approaches in terms of the capability and the practicality.

\section{Discussion}\label{sec:discuss}

It is observable that greybox fuzzing is quite effective in revealing implementation vulnerabilities caused by application crashes in a wide range of C or C++ programs. In fact, most of the binary CVEs assigned in the latest four years are found by fuzzers. In particular, \FOT and its extensions \dFOT and \mtfuzz have been able to discover more than 200 security bugs (c.f., Appendix~\ref{app:bugs}), among these 51 CVE IDs have been assigned. Despite that, it is worth noting that fuzzing itself almost only detects implementation relevant vulnerabilities caused by crashes which is rather specific to the applied program languages. Indeed, with some argumentation, fuzzing is able to detect certain logic errors by applying some differential fuzzing techniques~\cite{nezha}. However, the determination of the vulnerabilities still relies on the observations of crash behaviors that may or may not be artificially instrumented. As a result, fuzzing only copes with the very concrete issues occur in certain software. Moreover, Fuzzing cannot guarantee that the underlying programs are free of bugs as it essentially knows nothing about the actual coverage.

Quite the contrary, verification usually relies on top-down modeling of the vulnerability behaviors and rigor proofs. The merits are that verification guarantees that certain security property holds under all circumstances, and are not restricted specific software. However, the problem of verification is that the precondition required for proving is usually quite strict, greatly reducing the practicality of the approach. With the increasing complexity of the software, it is typically impractical to apply the verification by considering all the security-relevant properties. Fortunately, it is possible to abstract the interested these properties with the assistance of some manual efforts.

In this sense, I believe that there is no silver bullet: neither of testing or verification is perfect in securing the software systems. It is however possible to combine them by utilizing their strong points and mitigating their weaknesses.


\section{Conclusion}\label{sec:conclusion}


Testing and verification are two effective solutions to securing the software systems. In this thesis, we applied the greybox fuzz testing on the programs that may suffer from low level implementation vulnerabilities. To fulfill this, we implemented our fuzzing framework, \FOT, which features configurability and extensibility to cater for various fuzzing scenarios. Based on \FOT, we proposed two extensions that particularly handle two fuzzing scenarios: we applied \dFOT to handle the directedness guidance during fuzzing, and \mtfuzz to improve the efficiency of fuzzing on multi-threaded programs. Additionally, we applied the security type system verification to enforce the non-interference property in the Android like systems, which guarantees that the underlying system is free of information leakage as long as it can be well-typed. Undoubtedly, both of these two approaches have their own limitations, but they are complementary to each other in the sense that they safeguard the underlying systems with multiple levels of security requirements. In the future, we plan to integrate them to provide a comprehensive solution that can be used to reveal different aspects of vulnerabilities.
